#!/bin/bash
#
##
###             _
###  _ __   ___| |_ ___ ___  _ __  _ __
### | '_ \ / _ \ __/ __/ _ \| '_ \| '_ \
### | | | |  __/ || (_| (_) | | | | | | |
### |_| |_|\___|\__\___\___/|_| |_|_| |_|
###
###  _ _|_ _ ._    _  _
### (_\/|_(_)|_)\/(_|(/_
###   /      |  /  _|
###
### netconn
###
### (dis)connect to a network..., the right way
###
### usage: netconn [-k] [-s] [-h] [-w <wl_conf>]
###
### (c) 2019 - 2021 cytopyge
###
##
#


# script specific constants

script_name="netconn"
developer="cytopyge"
initial_release_year=2019
source_dir="$XDG_DATA_HOME/git/code/sources/functions"
temp_dir="$XDG_CACHE_HOME/temp"
netkill="$XDG_DATA_HOME/git/code/netconn/netkill"
hostname="myip.opendns.com"
server1="resolver1.opendns.com"
server2="resolver2.opendns.com"


# general function definitions

## define colors
source $source_dir/text_appearance

## reply functions
source $source_dir/reply_functions

## initial_screen
source $source_dir/splash_screen

## user authentication
source $source_dir/get_sudo


# read_flags

while getopts ":k:w:shq" opt; do

	case $opt in

		k)
			## -k netkill
			networks=${OPTARG}
                	sh $netkill
			exit 0
			;;

		w)
			## -w wireless network flag
			wl_conf=${OPTARG}
			;;

		s)
			## -s show splash screen
			show=1
			;;

		h)
			## -h display help text
			printf "netconn: usage: netconn [-w <config.wifi>]\n"
			exit 0
			;;

		q)
			## -q quiet
			quiet=1
			;;

		\?)
			printf "netconn: ${MAGENTA}invalid option: -${OPTARG}${NOC}"
			exit 1
			;;

		:)
			## display help
			printf "netconn: ${MAGENTA}option -${OPTARG} requires an argument${NOC}"
			exit 1
			;;

	esac

done


# specific function definitions


become_quiet()
{
	stty_0=$(stty -g)
	tput civis
	stty raw -echo
}


unquiet()
{
	stty $stty_0
	tput cnorm
	printf "[TEST]unquiet did run\n"
}


get_cursor_pos()
{
    #[TODO] countdown timer
    # Usage: get_cursor_pos
    IFS='[;' read -p $'\e[6n' -d R -rs _ y x _
    printf '%s\n' "$x $y"
}


create_temp_dir()
{
	[[ -d $temp_dir ]] || mkdir -pv $temp_dir
	t0=`date +%Y%m%d_%H%M%S`
	ip a > $temp_dir/'$t0'_netconn.tmp
}


netistat_1()
{
	net_1=$(sh $XDG_DATA_HOME/git/code/tools/netistat)
}

netistat_0()
{
	net_0=$(sh $XDG_DATA_HOME/git/code/tools/netistat)
}

netistat_d()
{
	diff <(echo "$net_0") <(echo "$net_1")
}


run_netkill()
{
    export from_netconn=1

    if [ -n "$(ip -br a | grep -i up)" ]; then

    	printf "disconnect current network connection? (y/N) "
    	#reply_single_hidden
    	reply_single_hidden_timed

		if printf "$reply" | grep -iq "^y" ; then

			clear
    	    printf "running netkill...\n"
    	    sh $netkill
    	    echo

		else

			echo
    	    printf "setting up connection...\n"
    	    echo

		fi

	fi

    unset from_netconn
    sleep 1
}


select_interface()
{
    # show default interface
    if [ -n "$wl_conf" ]; then

		## we do have a wl_conf flag

		## show wireless interface (wl*)
		show_default_interface=$(ip a | \
			grep '^[0-9]' |\
			awk -F ': <' '{print $1}' |\
			grep '^[0-9]\+:\swl')

    else

		## no wl_conf flag entry

		### show usb interface (enp*)
		show_default_interface=$(ip a | \
			grep '^[0-9]' | \
			awk -F ': <' '{print $1}' | \
			grep '^[0-9]\+:\senp')

		### show ethernet interface (eno*)
		if [ -n "$show_default_interface" ]; then

			show_default_interface=$(ip a | \
				grep '^[0-9]' | \
				awk -F ': <' '{print $1}' | \
				grep '^[0-9]\+:\senp')

		fi

    fi

    # select interface
    ip a
    echo

	if [ -z "$show_default_interface" ]; then

		printf "${MAGENTA}no default interface${NOC}, press ${YELLOW}o${NOC} to override "

		reply_single_hidden_timed

		if [ "$reply" == "o" ]; then

			echo

		else

			unquiet
			exit 10

		fi

	fi


    printf "enter preferred interface number [$show_default_interface]: "
    #reply_single_hidden
    reply_single_hidden_timed

    ## if no entry then when wl_conf<>0; then
	##	search wireless devices in ip a and select one that is up
    ## -n -> var lenght greater than 0
    ## -z -> var lenght equals 0
    if [ -n "$reply" ]; then

		## we have an entry for interface
		interface_number=$reply

	else

		## no entry for interface

		if [ -n "$wl_conf"  ]; then

			## we do have a wl_conf flag
		    ## try to autoconnect via wireless interface
		    auto_retrieved_interface=$(ip a | grep '^[0-9]' | awk -F ': ' '{print $2}' | grep ^wl)

		elif [ -z "$wl_conf"  ]; then

			## we do not have a wl_conf flag
			## try to autoconnect via ethernet (enp) interface
		    auto_retrieved_interface=$(ip a | grep '^[0-9]' | awk -F ': ' '{print $2}' | grep ^enp)

		elif [ -z "$auto_retrieved_interface"  ]; then

			## we do not have a wl_conf flag
			## still no auto_retrieved_interface acquired
			## try to autoconnect via ethernet (eno) interface
		    auto_retrieved_interface=$(ip a | grep '^[0-9]' | awk -F ': ' '{print $2}' | grep ^eno)

		else

			printf "${MAGENTA}no valid interface received, please try again${NOC}\n"
		    sleep 0.5
		    select_interface

		fi

	fi

    echo

    ## derive interface from interface_number
    interface=$(ip a | grep "^$interface_number" | awk '{print $2}' | sed 's/://')

	if [ -n "$auto_retrieved_interface" ]; then

		interface=$auto_retrieved_interface

	fi

    ## if interface is wireless, check for entered wireless network flag
    if [ ${interface:0:1} == 'wl' ] && [ -z $wl_conf ]; then

		echo
		printf "${MAGENTA}no wireless configuration allocated for $interface${NOC}\n"
		printf "${MAGENTA}point to a valid configuration with the 'w' flag'${NOC}\n"
		printf "exiting...\n"
		exit

	fi

    ## confirmation
    echo
    ip a | grep $interface
    echo
    printf "connect via interface $interface? (Y/n) "
    reply_single_hidden_timed

    if printf "$reply" | grep -iq "^n" ; then

		select_interface

	else

		echo
        echo
        printf "interface ${BLUE}$interface${NOC} selected\n"
		sleep 0.5
		echo

	fi
}


set_interface_up()
{
	sleep 0.5

	sudo ip link set $interface up

	if [ $? -eq 0  ]; then

		printf "interface $interface ${BLUE}up${NOC}\n"
		echo

	else

		printf "interface $interface ip link ${MAGENTA}error${NOC}\n"
		printf "exiting\n"

	fi
}


check_wireless_interface()
{
	wireless=0

	if [[ $interface == wl* ]]; then

		wireless=1

	fi
}


wireless_network_select()
{
	if [ $wireless == 1 ]; then

		# select wireless network from list
		wpa_supp

	fi
}


wpa_supp()
{
	sudo systemctl start wpa_supplicant.service
	systemctl status wpa_supplicant.service
	sudo wpa_supplicant -B -i $interface -c $wl_conf
	echo
}


dhcp_connect()
{
	sudo systemctl start dhcpcd.service
	systemctl status dhcpcd.service
	sudo dhcpcd $interface
	#sudo dhcpcd -w $interface
	#sudo dhcpcd --waitip $interface

	echo
	printf "getting host information from dhcp server\n"
	printf "configuring network interface $interface\n"
	#printf "writing DNS configuration to resolvconf\n"
	#resolvconf -i
	sleep 3

	echo
	printf "checking if interface $interface reports a working carrier\n"
	printf "trying to obtain a lease, then forking to background\n"
	sleep 3

	if [ $? -eq 0 ]; then

		echo
		printf "interface $interface ${BLUE}connected${NOC}\n"
		printf "dhcpcd daemonizing...\n"

	else

		echo
		printf "${MAGENTA}$interface not able to obtain lease${NOC}\n"
		printf "exiting\n"
		exit

	fi

	echo
}


enable_dns()
{
	# systemd dns resolving service
	sudo systemctl start systemd-resolved.service
}


wl_info()
{
	if [ $wireless == 1 ]; then

		echo
		iwconfig $interface

	fi
}


ext_ip_info()
{
	#exip=$(protonvpn s | grep IP: | awk '{print $2}')
	#exip=$(curl -4 https://ifconfig.io)
	#exip=$(dig myip.opendns.com @resolver1.opendns.com +dnssec +short)

	printf "obtaining external ip address...\n"

	try=0
	while [[ -z $exip ]]; do

		sleep 1
		let try++
		exip=$(host "$hostname" "$server1" 2>&1 | \
			tail -n 1 | rev | cut -d ' ' -f 1 | rev)
		#exip=$(dig myip.opendns.com @resolver1.opendns.com +dnssec +short)
		#exip=$(protonvpn s | grep IP: | awk '{print $2}')

		sleep 1
		if [[ -z $exip ]]; then
			exip=$(host "$hostname" "$server2" 2>&1 | \
				tail -n 1 | rev | cut -d ' ' -f 1 | rev)
		fi

		#[DEV]
		printf "try: $try\n"
		printf "exip: $exip\n"

		[ $try -ge 10 ] && return

	done

	#printf "external ip: ${YELLOW}$exip${NOC}\n"
	#protonvpn s
}


show_ipa_diff()
{
	t1=`date +%Y%m%d_%H%M%S`
	ip a > $temp_dir/'$t1'_netconn.tmp

	diff $temp_dir/'$t0'_netconn.tmp $temp_dir/'$t1'_netconn.tmp

	# diff gives exit status code 1 if files are different
	# therefore we can't execute an && after netconn
	# this is the (ugly) repair
	#[TODO] find a neater solution
	echo > /dev/null

	# newline
	echo
}


unblock_radios()
{
	if [[ ${interface:0:2} == 'wl' ]]; then

		sudo rfkill unblock wlan
		rfkill
		echo

	fi
}


connect_protonvpn()
{
	echo
    printf "connecting vpn, press n to abort "
    #reply_single_hidden
    reply_single_hidden_timed
	echo

    if printf "$reply" | grep -iq "^n" ; then

		return

	else

		sleep 3
		sudo protonvpn c --cc SE -p udp
		sleep 3
		protonvpn s

	fi
}


connect()
{
	create_temp_dir
	[[ -n $show ]] && splash_screen
	get_sudo
	netistat_0
	run_netkill
	select_interface
	unblock_radios
	set_interface_up
	check_wireless_interface
	wireless_network_select
	dhcp_connect
	#enable_dns
	wl_info
	ext_ip_info
	show_ipa_diff
	#connect_protonvpn
	sleep 2
	netistat_1
	netistat_d
}


case $quiet in

	1)
		get_sudo
		#become_quiet
		{
			connect
		} 1>/dev/null 2>&1
		#exec >/dev/null
		#exec 2>&1
		#connect
		#unquiet
		exit
		;;

	*)
		connect
		;;

esac
